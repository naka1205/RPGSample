---
title: 战斗规则
date: 2019-05-27 14:40:57
tags: [战斗]
comment: false
categories: 战斗
createtime: 1558940168
description: 战斗这个部分在进入程序逻辑之前,还是要先想一想“规则”。游戏规则可能在主体设计时就已经决定好,但通常只是拟出大致上的规范准则,很少连细节都规定得一清二楚,所以开始动手做的时候就会出现一些问题,也许是忘了规定、或者是定义太笼统含糊等等。
---
###战斗规则

战斗这个部分在进入程序逻辑之前,还是要先想一想“规则”。游戏规则可能在主体设计时就已经决定好,但通常只是拟出大致上的规范准则,很少连细节都规定得一清二楚,所以开始动手做的时候就会出现一些问题,也许是忘了规定、或者是定义太笼统含糊等等。

####决定判断例程(Routine)

第一个要确定的就是“判断例程”,这部分相当于“审理判断”。
根据“攻击力”、“防御力”等参数,决定要给对方多大的破坏力,如果把随机数都算进来的话,“命中率”和“临界值”之类的也会有影响。从这些数据指数,利用计算式求出破坏力。破坏力的公式不会强制“一定要怎么做”,游戏玩家可以自由决定,不过既然用公式求出结果,当然还是要参考结果去选择罗!

####计算时所需的参数

在决定计算公式之前,再回顾--下必要参数的意义吧!
* 攻击力:提高破坏力
* 防御力:降低破坏力
* 命中率:攻击的成功率
* 临界值:临界爆发(更多攻击)的比率

这里的数值是加计能力等级和小道具效果后的数值。没有其他外力的“原始”数值就姑且称为“基本攻击力”或“基本防御力”。

举例来说,若攻击力跟基本攻击力两者间的关系为:

**攻击力=(基本攻击力+小道具效果)×等级**

若设为直接乘以等级,则当等级从1提升到2时,攻击力就会变成2倍,不过若等级从10提升到11时,则攻击力只提高1/10而已,如果想解决这个问题,也可以设定成每个等级都有相对应的常数(或者改用其他计算方式)。

状态画面上所显示的攻击力可能是指“攻击力”,也可能是“基本攻击力”,要看游戏是如何定义。通常基本攻击力是根据武器等级而定时,则代表“基本攻击力”,若是指游戏玩家的目前状态时,则代表“攻击力”。

道具效果可依字面解释,指因拥有该道具而增加(或减少)的数值,例如“提高攻击力的魔戒”等。

####计算破坏力

为了简化说明起见,计算“破坏力”时的前提要件是不受随机数影响。这样就可以只考虑攻击力和防御力的参数。

因为攻击力的作用是“提高”,而防御力的作用是“抵销”,按照这个简单的逻辑可推算出如下的计算公式:

**破坏力=攻击力一防御力**

如果使用这个公式,当防御力大于攻击力时破坏力会变成负数,显然有漏洞。当然你也可以设成若此公式计算结果为负数时,则为“0”或“1”,但再怎么处理,这个公式中的防御力效果还是太好。

下面这个公式可以降低防御力的影响程度:

**破坏力=攻击力 × A 一 防御力 × B**

A、B均为常数。若A之值大于B,则能降低防御力的效果,但这不是根本的解决之道。

发现了吗?对,不能用“减算”去求。那么,改成除算看看好了。

**破坏力=攻击力 / 防御力 × A**

直接用攻击力除以防御力时,若攻击力和防御力两者相当,则破坏力之值会接近“1”。为了避免破坏力之值有太多计算结果接近“1”,因此再乘以常数A。不过,这里又出现另外一个问题。当你遇到等级提高,而攻击力和防御力均变大时,所求出的破坏力就一成不变。

**破坏力= 攻击力 × 攻击力 / 防御力**

若计算公式修改如上,则当攻击力和防御力两者相等时,你的“攻击力”就是破坏力,这样看起来比较好。所以,这里就决定采用最后的计算公式。我们的最终目的还是在“能有比较好的结果”,因此多想一些不同的计算公式比较看看会很有用的。

除了上述的计算公式之外,还有很多方法可以求出破坏力。各位只要上网打入关键字“RPG”、“计算破坏力”进行搜寻,就会跳出一大堆,从现有游戏的公式说明、到自制游戏的破坏力计算方法都有(要简单型、还是复杂型,任君选择)。

####随机数

如果只有数值计算,CPU会老是出现同一个动作,而且两边的破坏力也没什么变化。更糟的是,只要某个打法赢过一次就永远都不会输了。

这就是为什么要利用随机数的理由。如果计算公式含有随机数,同一套游戏就很难用“必胜方程序”打赢。版图式游戏的随机数有点像是“掷散子”。

在什么情形之下要用到随机数?例如,发生“临界爆发”、“攻击失败”时,或是增减破坏力等的计算值。请注意,如果两种方法混用可能会不知所所以应适时、适当使用即可。

随机数除了可以增加游戏的“偶发性”、提高游戏的趣味性,也可能让人烦躁,产生“哇,怎么会这样!”的负面感觉,最好不要设计太多负面走向,否则消费者玩起来很难兴致高昂。

请各位注意一下,“临界爆发的出现比例为10%”并不等于“10次出现1次”,它的真正意思是每次攻击时有10%的概率会变成临界爆发。

如果概率设为10%,连续出手2~3次就出现一次临界爆发的话也说得过去(考虑一下实际玩游戏时的攻击次数,连续出手3次时好像就会有)。如此来,若敌方被连续3次临界爆发攻击,很有可能就玩完了。反过来,这道理也可以应用在连续3次攻击失败的情况。

随机数影响力太高时,策略反而就英雄无用武之地,所以别越写越高兴而弄了太多随机数喔!

#####随机数的临界爆发攻击

如欲利用随机数产生临界爆发攻击时,只要写成:
```C++
attack = ...; //
if( rand % 100 < 10 ){
	attack += 2;
}
```

rand是产生虚拟随机数的函数。由于rand值除以100的余数小于10的概率为10%,故设计成当余数小于10则破坏力增为2倍,那么破坏力增为2倍的概率就有10%。严格说来,除数为100时所得的余数并不平均,不过这里只是举例说明,就别那么斤斤计较啦!

既然游戏设计是要“审理判断”攻击的结果,随机数就不应该用在判断不到的地方(即游戏玩家视野范围之外)。随机数必须用在“有显示出来”的数值。要是“审理判断”只是随便敷衍了事,这个游戏根本就不必再玩下去了(游戏在“掷散子”时,一定要在所有人看得见的地方掷)。

####求出射程距离

攻击范围(射程距离)的求法同移动范围。近距离攻击(使剑或空手对打等)和远距离攻击(如弓箭)的计算方式看起来好像不同,不过范围的求法是递进性适应“范围1”,所以可以使用同一个逻辑。

近距离攻击跟远距离攻击两边对于障碍物的看法或许不太一样,但是在范围1时并不能越过障碍物攻击,因此不会有问题。

移动时会用“MapData:ChkMove”判断障碍物,但攻击时的判断还要另外写一个“MapData:ChkAttavck”。

`MapData:ChkAttavck`函数会忽略方格上的敌人或障碍物,所以只要用前面移动距离说明过的“脚印”做判断即可(这里并不是移动,用“脚印”来形容有点不伦不类,不过硬要改称“标记”也太矫杆过正,因此照旧称为“脚印”)。

```C++
// 是否可以攻击
bool ChkAttack(int _dist)
{
	return attack_dist < _dist;
}
```

判断完成后,再利用sprite显示射程距离,如图6-1所示。
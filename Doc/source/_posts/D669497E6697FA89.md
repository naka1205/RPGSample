---
title: 地图坐标系
date: 2019-05-18 13:20:15
tags: [显示地图,显示人物]
comment: false
categories: 显示地图和人物
createtime: 1558590067
description: 必须先有一个坐标系,才能显示地图或人物。如果使用的地图是垂直向下看的方格地图,画面显示的坐标系即同地图的坐标系(只须放大或缩小),不必太花时间,但如果是45°全视角的画面,就需要转换坐标值。
---
###地图坐标系

必须先有一个坐标系,才能显示地图或人物。

如果使用的地图是垂直向下看的方格地图,画面显示的坐标系即同地图的坐标系(只须放大或缩小),不必太花时间,但如果是45°全视角的画面,就需要转换坐标值。

不先处理好坐标转换的问题,甚至会无法做移动测试,所以我们就先从这里开始解起吧。

45°全视角的坐标系即如图4-1所示。

####从地图坐标转换成画面坐标

我们先想想从地图坐标转换成画面坐标时的转换式。转换成画面坐标时,就已经从“点”变成“方格”,所以要求出框住菱形外围的矩形的“左上角”坐标,如图4-2所示。

框住菱形外围的矩形大小是“64×32”,而在640×480的画面(程序区域)上则可显示10×10的地图。因为方格间有互相重叠,所以画面坐标的最小单位是这个尺寸大小的1/2(长X宽=16×32),如图4-3所示。

这时候,可以先用一个比较容易算的数值试算看看。最容易算的数值当然是“0”。地图坐标为“0,0,则画面坐标为“X=0”,Y坐标则偏移6个方格(最小单位:12),如图4-4所示。故可得出下列公式:

地图X坐标(map_X)每增加1,画面Y坐标(viewY)就会相对减少1。也就是说:

```
view_x=map_x"(MAPGRID_WIDTH/2)
iew_y=(12-map_x)*(MAPGRID_HEIGHT/2)
```
而地图Y坐标(map_Y)每增加1,画面X坐标(view_XY)也同样增加1。

```
view_x=000000ap_x+map_y)*(MAPGRID_WIDTH/2)
view_y=(12-map_x+map_y)*(MAPGRID_HEIGHT/2)
```

地图坐标和画面坐标两者的转换公式即如上所示。

####从画面坐标转换成地图坐标

反过来的话,要如何从画面坐标求出地图坐标?

公式转换的计算单位是像素,不过像素坐标都是整数,如果求出的结果不是整数时还是会强迫改成整数。因此计算结果可能会有1像素的误差(这是无条件进位或无条件舍去时所产生的误差,所以或许可以视为一定会有误差)。

#####利用渐变色地图

先在内存上做一个“渐变色地图”搭配使用也是一种方法,如图4-5所示。

这种方法的优点是能适用于各种不同形状的地图。受限于印刷问题,虽然上图使用黑白两色,实际上X坐标用红色、Y坐标用蓝色会更容易判断坐标位置。

因为这里的目的只是为了“用鼠标指出”,并不需要太严格要求,所以先用计算式就好了。有关渐变色地图的部分,在Chapter9的“直接跳跃(directjump)”还有详细介绍,有兴趣的读者可以先翻过去参考看看。

#####坐标转换的计算式

首先,方格的长宽比例是“2:1”,所以画面Y坐标要放大2倍。然后地图坐标也要从方格单位改成像素单位,即地图坐标乘以64倍,0~63为“0”、64~127为“1”……以此类推(因为画面坐标是以像素为计算单位)。

试求画面坐标“0,0”时的地图坐标。地图Y坐标跟画面坐标总共偏移了6.5个方格,所以要把偏移的部分改正回来。

```
view_y=MAPGRIDHEIGHT*13/2;
```

因为这是整数运算,所以要写成13/2而非6.5。接着,再把Y坐标放大2倍。

```
view_y*=2;
```

最后再套用地图坐标转换成画面坐标时的模式,即可得到下列公式:

```
map_x=(view_x-view_y)/MAPGRID_WIDTH
map_y=(view_x+view_y)/MAPGRID_WIDTH
```

诈看之下,这个公式似乎符合基本的数学逻辑,但是里面隐藏着bug!

地图坐标转换成画面坐标时的计算都在地图坐标的范围之内,所以公式运算不会有问题,但从画面坐标转换成地图坐标时却需要考虑到“不在范围之内”的部分。“不在范围之内”是指在画面上(窗口内)、但未显示菱形方格(地图)的部分。

不在范围之内的坐标值可能会让“viewx-viewy”或“viewx+viewy”变成负数。这里本来就是整数运算,故计算结果如图4-6所示,0的长度会明显比其他数字长。

如此来,当结果出现负数时就会偏移1个方格,也没办法直接两数相除。各位可以参考以下几种解决方法。

#####解法(1):实数运算

如果问题是出在整数运算,改用实数运算就可以解决问题。实数运算(浮点小数运算)可以使用“floor”函数。利用floor函数就能得到预期中的数值(“floor(x)”会传回表示【以下的最大整数】的浮点小数值)。
应用floor的公式即为:

```
map_x=int(floor(double(view_x-view_y)/MAPGRID_WIDTH
map_y=int(floor(double(view_x+view_y)/MAPGRID_WIDTH
```


#####解法(2):应用移位(shift)

即使直接做整数运算,有时不用除法改用移位(shift)反而能得到预期中的数值。应用移位的公式即为:

```
map_x=(view_x-view_y)>>6
map_y=(view_x+view_y)>>6
```

移位分成“算术移位(Shiftarithmetic)”和“逻辑移位(Shiftlogical)"两种。

利用算术移位可以得到想要的结果,但逻辑移位会让负数变成很大的正数。其实就算变成再大的正数,都还是“不在范围之内”,所以不成问题。

不过,移位只能利用在2的乘暴计算(2、4、8、16..)而已,用途比较有限(因为本书的程序实例是把地图坐标放大成64倍,故可使用移位)。

#####解法(3):加上offset(位移偏差)

为计算中出现负数才会发生问题,那把计算范围限制为正数就OK啦。

```
map_x=(view_x-view_y+MAPGRID_WIDTH*10)/MAPGRID_WIDTH-10
map_y=(view_x+view_y+MAPGRID_WIDTH*10)/MAPGRID_WIDTH-10
```

如果偏移的方格数日高达10个,确实就不在范围之内。只要事先加上适当数值,等到除算后再减去该数值即可(若不在范围之内实不需要正确数值,则offset值可设为“1”。offset值为1时,-1的范围会变大,但-1已经不在范围之内,所以没关系。)

#####解法(4):分类处理

利用计叙述分成负数、正数两种不同情形该如何进行计算,即可得到正确的计算结果。

不过,最近的CPU不太擅长处理条件分支,而且一进入条件分支之后来源代码的“流向”就会被分开,降低整个程序的可阅读性。相信有不少读者最先想到的就是“分类处理”,但很多时候不一定非用分类处理的做法不可,建议多动动脑想些其他的做法。
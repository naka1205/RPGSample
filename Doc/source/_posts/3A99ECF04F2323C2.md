---
title: 战略型即时系统的基本概念
date: 2019-05-30 15:05:27
tags: [即时]
comment: false
categories: 浅谈即时系统
createtime: 1559200511
description: 讲到战略型即时的战斗,马上会联想到动作系列的游戏,如“射击游戏”等。如果想让RPG也采取即时性动作,就要改成类似射击游戏的结构。
---
###战略型即时系统的基本概念

讲到战略型即时的战斗,马上会联想到动作系列的游戏,如“射击游戏”等。如果想让RPG也采取即时性动作,就要改成类似射击游戏的结构。

不过,就好像射击游戏只能操控“主角”一样,如果做法完全抄袭射击游戏,游戏玩家所选人物中就只能操作主角而已。

因此在即时性处理中,“只有移动”的类型会占大多数。

####游戏玩家所选人物的移动

我们先把眼光集中在游戏玩家所选人物的状态。

移动方向有4种,系统大致上跟两边轮流出手型的系统差不多。两边轮流出手型的移动步骤如下:

* ①显示移动范围
* ②移动

假设移动范围只能“1步”。因为即使不显示移动范围,也知道在哪个地方,所以就省略掉显示动作。同样,移动也只能移动4个不同的位置,因此利用前后左右方向的代表键或箭头方向键就能移动。

既然系统差不多,应该把Chapter5的移动实例修改一下就好了。技痒了吗?做做看吧!

战略型即时移动(Battle.cpp)

```C++
void CBattleAction::KeyDown(UINT key)
{
	if (status == STATUS_NONE) {
		CCharacter &s = player_list.back();
		CPoint pos = s.GetMapPoint();

		switch (key) {
		  case VK_UP:
			if (pos.y > MapRect.top && map_data[pos.y - 1][pos.x].type == NONE) {
				map_data[pos.y][pos.x].type = NONE;
				map_data[pos.y][pos.x].sprite = 0;
				anime.push_back(MoveAnime(&s, CCharacter::UP));
			}
			break;

		  case VK_DOWN:
			if (pos.y < MapRect.bottom - 1 && map_data[pos.y + 1][pos.x].type == NONE) {
				map_data[pos.y][pos.x].type = NONE;
				map_data[pos.y][pos.x].sprite = 0;
				anime.push_back(MoveAnime(&s, CCharacter::DOWN));
			}
			break;

		  case VK_LEFT:
			if (pos.x > MapRect.left && map_data[pos.y][pos.x - 1].type == NONE) {
				map_data[pos.y][pos.x].type = NONE;
				map_data[pos.y][pos.x].sprite = 0;
				anime.push_back(MoveAnime(&s, CCharacter::LEFT));
			}
			break;

		  case VK_RIGHT:
			if (pos.x < MapRect.right - 1 && map_data[pos.y][pos.x + 1].type == NONE) {
				map_data[pos.y][pos.x].type = NONE;
				map_data[pos.y][pos.x].sprite = 0;
				anime.push_back(MoveAnime(&s, CCharacter::RIGHT));
			}
			break;

		  default:
			return;
		}
		StartAnime();
	}
}
```

删除鼠标输入的部分,另外加上“键盘”输入。

请执行附赠光盘中“chapter10”文件夹下的程序实例看看。移动的动画对应“多步移动”等一些较元长的部分都没有删掉,不过应该可以确认程序实例能配合“键盘”输入前后左右移动才对(障得物也还在)。

地牢和迷宫的移动大概只要有这些处理就够了。如果设计成当人物所在位置有发生什么事(从map_data[pos.y]lpos.x]可得知)就会发生事件或战斗,一个可以自由移动的地牢系统就完成了,如图10-1所示。

如果是在地牢或迷宫的场景,只要把障碍物的CG画得跟方格一样大,而且紧密排列,就算用现在的“地图显示”的逻辑也可以绘制得出来,如图10-2所示。

如图10-1将零件紧密排列起来,就成了“地牢墙壁”。已经有放零件的部分是禁止移动,故直接当作“墙壁”处理。

要是墙壁和地板再贴上“磁砖”或“岩石”的纹理加强质感,看起来就更像了。

如果处理的是移动用地牢,程序有很多地方倒是可以跟两边轮流出手型的战斗共用。

#####更自由的移动系统

移动系统还可以设计得更自出一点,例如利用analogstick操作、或者朝着鼠标键按下位置移动。

如欲追求更自由的移动,则管理时需使用“坐标”而非map_data之类的数组。

判断是否为“禁区”时,利用Chapter9的“涂色区分地图”CG和可进入/禁止进入间的对应。此时,产生事件可以用“当人物进入有效坐标的范围内时”的出发方式,如果是固定位置的事件,也可设定涂色区分地图的“红色区为事件”不等。

不过,移动要更自由的话,人物方向应该“最少有8个方向”。否则有些移动方向会看起来好像是斜行前进,很不自然。

####敌方人物的移动

即时系统对于敌方人物移动的限制比两边轮流出手型的更严格。不仅一次只能移动1步,而且因为对手(即游戏玩家)随时都在移动,所以在决定移动位置时不能考虑得太多。

弄到后来,敌方人物的动作不是“接近”、“逃开”,就是“按照既定的路线移动”。

由于“即时拼图游戏(Real-timePuzzleGame,动态拼图游戏)”的敌方人物就是应用这个逻辑而移动,故可利用同样的思考模式。

主角是用键盘操作,但敌方人物却是由计时器来操作。如果这里不用计时器,改成“当主角移动时”,敌方人物也相对有1个移动,这个系统就比较偏向“半即时性”了。半即时性系统的优点是即使游戏玩家手酸了停止操作,也不必担心敌人会来愉袭。

战斗开始有两种状况,因跟游戏玩家所选人物相邻而开始战斗,以及因两者重叠(接触)而发生战斗。

####战斗

战斗通常不是即时性,多半会转成两边轮流出手型的战斗,不过当中也会有即时性的战斗形式。即时性的战斗形式很容易造成“连续狂按键盘”,让RPG游戏变得像是动作游戏。

即时性战斗的处理比较简单,只要设定按键“1”(或“Z”、其他键)为“抑剑”,按键“2”(或“X”、其他键)为“射箭”等等,往按下按键时该人物所朝的方向攻击即可(敌方人物的动作亦同)。

这跟射击游戏最大的差别是“挥剑攻击”。射击游戏则是发射子弹,基本上它是一种“远距离攻击”,而且自己飞机和敌机相撞时会承受到对方的破坏力,相形之下,RPG是以近距离的肉搏战为主,所以攻击逻辑和判断都得跟射击游戏不一样。

只有在自己飞机的动作和敌机的移动方式(尤其是朝己方飞机迎面而来的敌机)可以应用同样的思考模式,当然罗,马箭之类的远距离攻击就跟射击游戏一样了。

其实最贴近射击游戏的特征还是在“需要有绝佳的第一时间反应”。

如果是两边轮流出手型,从“指示动作”到“执行动作”即使有空档也不太感觉得出来,但在即时型系统时,这个“空档”会让人觉得反应迟钝。
---
title: 移动的动画
date: 2019-05-24 14:30:16
tags: [人物,移动]
comment: false
categories: 人物移动
createtime: 1558680670
description: 在处理人物的移动时,要是转瞬间就突然出现在移动位置,好像太单调了一点。一般人物造型可以让它“走过去”,而怪兽、机器人造型也可以边做什么动作、边移动过去,这样不是很有趣吗?
---
###移动的动画

在处理人物的移动时,要是转瞬间就突然出现在移动位置,好像太单调了一点。一般人物造型可以让它“走过去”,而怪兽、机器人造型也可以边做什么动作、边移动过去,这样不是很有趣吗?

试试看吧,做个动画格式让人物大摇大摆的走过去。

####动画格式

有脚的人物前进时,是两脚一左一右往前踏出去。

也就是说,只要不断切换右脚向前和左脚向前的CG,就能产生行走的视觉效果。但是两个动作之间总是要有其他动作帮忙串场,所以还要有一张两脚在同样位置的CG插在中间才会自然。动画格式的CG其实不需要太细微的小动作,中间衔接的CG只要拿站立静止姿势的CG就很好用了。

如图5-11不断重复“右一中间一左-中间-右……”,同时配合移动人物位置,步行的姿态就很自然了。

这个模式是所需CG图数量最少的步行模式。虽然说数量已经很少,但如图5-12所示,光一个移动的动作就需要12个不同模式的CG图。

当然如果你坚持慢工出细活,也没什么错,不过请先考虑一下每个出现的人物都要有4个方向的模式,制作得太精致反而会加重作业的负荷喔!

####登录动画

移动是利用前面4个模式,按照“中间”一“右脚前”+“中间”一“左脚前”的顺序不断循环。因此把1个方格内的移动设成1个循环的话,以后只要用同一个模式即可,而且循环的结束动作若设为“中间CG”,停下来的时候就不需要特别做处理。

请根据这几个原则,想一想要如何寻找移动路线和登录动画。

```C++
void MoveCharacter(int x, int y, int 步数)
{
	if(回到起点){
		return;			//结束
	}
	步数++;
	if(上一格的步数 == 步数){
		MoveCharacter(x, y-1, 步数);
		登录动画(下);
	}
	else if(下一格的步数 == 步数)){
		MoveCharacter(x, y+1, 步数);
		登录动画(上);
	}
	else if(左一格的步数 == 步数)){
		MoveCharacter(x-1, y, 步数);
		登录动画(右);
	}
	else if(右一格的步数 == 步数)){
		MoveCharacter(x+1, y, 步数);
		登录动画(左);
	}
}
```

寻找路线是先找到“目前步数(脚印)+1”的步数的方格并移动过去,再回到起点后才算结束。寻找的顺序是“上一下一右一左”,往条件符合的方向前进。

这个部分也使用了递归。等到从MoveCharacter成员函数的调用返回之后,再把符合移动方向的动画登录到内存。

我们按照动作顺序走走看,假设抵达位置的坐标是(3,4),出发点坐标是(2,2),如图5-13所示。

整个寻找路线的处理可整理如下:
* 先调用一开始的MoveCharacter(3,4,1)
* 因为“上一格”符合条件,故调用MoveCharacter(3,3,2)
* 因为“上一格”符合条件,故调用MoveCharacter(3,2,3)
* 因为“左一格”符合条件,故调用MoveCharacter(2,4)
* 此时,已经回到起点,故“return”
* 从MoveCharacter(2,2,4)返回,登录“动画(右)”
* 从MoveCharacter(3,2,3)返回,登录“动画(下)”
* 从MoveCharacter(3,3,2)返回,登录“动画(下)”
* 最后,从一开始的MoveCharacter(3,4,1)返回并结束

我们得到的动画登录顺序是“右+一下”,照这样移动看看!从图5-13的④(坐标2,2)依照这个移动顺序出发,就会抵达①(坐标3,4)。原来“反序”登录是这个意思。

最后一个动作,利用计时器依序让已登录的动画模式在画面上跑,设定的人物就会开始步行移动。

***
递归调用(recursivecall)
***
有些人认为逆归调用是最难搞懂的部分之一,其实递归调用本身并没那么难,比较难懂的应该是使用时机。

“不知道怎么用,所以没用过”,“没用过,所以也没想过要去了解”,“没1下过功夫,所以还是一头家水”,怎样,听起来很熟悉吧?

递归调用中最常出现的就是“阶乘”,即“n!=n*(n-1)1(但n为1时,其值为1)”,写成程序则为:

```C++
int factortal(int n)
{
	if(n == 1)
		return 1;
	return n * factortal(n-1);
}
```
有时候利用循环可能还比递归调用更有效率,而且很多时候就算使用递归调用也不见得有什么好处,也许这就是一般人不太熟悉递归调用用法的最大理由。

就拿本书的程序实例来说,寻我移动范围(FindDistance)时利用递归调用会比较好写,但寻找移动顺序(MoveCharacter)若想用循环也是三两下就搞定。

先考虑用循环去写,若发现用循环结构可能会变得很复杂时,不妨改用逃归的概念反而可以化繁为简。觉得先考虑递归结构,遇到“尾端递归(tailrecursion)”时再改成循环当然也通喔!

尾端递归是指在处理的“尾端”做递归。
---
title: 移动的思维方式
date: 2019-05-24 13:55:50
tags: [人物,移动]
comment: false
categories: 人物移动
createtime: 1558679515
description: 含有版图游戏式战斗的RPG通常是一次操作不会只能移动一步,移动步数要做成可依人物特征或武器配备等因素而改变。
---
###移动的思维方式

含有版图游戏式战斗的RPG通常是一次操作不会只能移动一步,移动步数要做成可依人物特征或武器配备等因素而改变。

####判断可移动的位置

人物移动时,首先要判断可移动的位置。只是一步步移动的话倒是不一定要做判断,但是移动不只一步的时候,判断这部分会有点费事。如果前面没有障碍物,则只需按照特定的动作模式进行即可,不过地图上通常不会没有障碍物。

我们先来看看移动一步的情况是怎样。

移动一步时只有前后左右移动一格的动作,比较简单。遇到前有障碍物也只是不能移动到该方向而已,这种判断不太难,如图5-1所示。

那么,换成走好几步(假设4步)的话呢?

前方无障碍物时,则前面4格都是可移动的位置。若有障碍物,则“绕过”障碍物的总距离也需一并判断,就比较复杂了,如图5-2所示。

执行移动时,也要做动画处理让人物能在方格上行走,要是前有障碍物还不懂得绕道而行,这个地方就很奇怪了。因此“确认移动距离”和“移动到指定位置”两者的思维方式相同。

####确认移动距离

要怎样检查可不可以移动呢?

移动距离只有1步时比较简单,前、后、左、右都是“有障碍物,不可移动”或“无障碍物,可移动”,单纯的判断就能处理。

如果距离拉长一点,2步也许还能勉强用迁语句敷衍过去。移动距离再长一点,例如3、4步的话就开始捉襟见肘了。有些人可能想一不做二不休硬干,恭喜你,你得写一大堆函数,1步用的函数、2步用的函数、3步用的函数…,不知道要写到几步才够用,但唯一可以确定的是,这样写出来的程序根本不实用。

我们在判断是否可以移动的时候,基本上脑海里会自然而然的移动看看(当然只是凭空想像)。在CPU端实际移动看看也是一种方法(在内存中)。

假设现在要判断4步的移动,先实际移动4步看看,设定让人物“凡走过必留痕迹”,那么只要有留下脚印的都是可以移动的位置(事实上也移动过了)。

至于1步的移动,那就更简单了。也就是说:

* 判断是否可移动4步=先走1步,再判断是否可移动3步
* 判断是否可移动3步=先走1步,再判断是否可移动2步
* 判断是否可移动2步=先走1步,再判断是否可移动1步
* 判断是否可移动1步=先走1步看看

根据以上的逻辑,整个过程就只需要做移动1步的判断处理而已。

同理可推,欲求出n步的处理时即可利用下面的公式:

**1步的处理+(n-1)步的处理**

```C++
void FindDistance(int x, int y, int n)	//是否可移到n步
{
	脚印[y][x];		//留下脚印
	if(n==0)
		return;			//处理结束
	if(可上移)
		FindDistance(x, y-1, n-1);		//接下来得判断
	if(可下移)
		FindDistance(x, y+1, n-1);		//接下来得判断
	if(可右移)
		FindDistance(x+1, y, n-1);		//接下来得判断
	if(可左移)
		FindDistance(x-1, y, n-1);		//接下来得判断
}
```

从FindDistance函数再调用本身FindDistance,这种调用自己本身的处理称为“递归调用(recursive call)”

按照这样的思维逻辑,只要有一个1步移动的判断处理,就能应用到n步移动的判断处理。而且这种方式的移动范围可以无限延伸扩大(范围越大,计算内容就越大,有没有人知道速度的极限最高能撑到几步)。

#####验证移动判断

理论上,上述的方法好像行得通,不过到底是真行、还是假行,图解看看就知道了!步数太多反而会乱,先假设是移动3步好了。1步或2步不够多可以“绕过”,所以验证时至少要3步以上。

假设移动时所经过的方格都会留下从起点起算的步数和脚印,只要方格已经被走过(有脚印)就算已经走开,不再做判断处理。判断处理的先后顺序是上、下、右、左,如果无法上移时,处理再依序住其他方向进行处理,如图5-4所示。

我们先往上走1步,用“相同的处理”判断是否可移动第2步。

第2步也是做相同的处理。先往上移动1格,再判断第3步。

因为这里验证的移动只有3步,所以走到第3步之后就不必继续做移动判断。故第3步的位置只留下脚印。

这些是往上移动的判断,继续要做往下移动的处理。但是由于下面已经有“脚印”,所以在第2步的位置要做的是右移第3步的判断。右移第3步也同样只留下脚印,接着再判断左移的第3步(要留下脚印),如图5-5所示。

到这里为止是整个第1步往上移动时的判断处理。我们再回到第1步的方格,继续做处理。因为下面已经有脚印,所以能做的处理是右移处理以及左移处理。

这就是从起点出发的第1步往上移动时的判断处理。接下来,往下移动时的判断处理也如法炮制。像这样,连往下移动的处理也完成后,就变成如图5-7。

继续进行第1步右移的处理,不过起点右移1步的位置已经留有脚印,左移1步也是。换句话说,理论上处理动作应该在这里就要结束,但各位不觉得这个结果有点奇怪吗?对了,右(左)移的第1步被上移的第3步挡住了。

别急,这个小问题不是没解的问题。起点往右的第1个方格会留下的脚印是“1”,而已经留下的脚印却是“3”,所以只要设定为“欲留下的新脚印数值小于旧脚印数值,则处理继续进行(即覆盖掉旧脚印)”,加入这个“规则”之后,左右移的处理就可以继续进行,如图5-8所示。

OK,那我们就根据这个“规则”来处理看看!

####移动到指定位置

在可移动的范围之内,移动到指定位置的方法有好几种,但是再怎么简单的方法都会踢到“障碍物”这个大铁板。

以最简单的移动方法为例,像是往最靠近目的地的方向一步步移动,最后要抵达目的地。理论上,遇到障碍物时,只要绕过去就能正常移动,但是这种方法会有问题。假设地图上现在有一个如图5-9的死巷,如果从起点想往离目的地最近的方向移动,根本就动弹不得,反过来先离目的地远一点后再前进才是最近的路线。

这个假设状况有点故意,但不能百分之百保证不会有这样的情形出现,所以还是得把它考虑进去。当人物遇到一步步接近的方法行不通的时候,就要采用其他方法。

我们到陌生的地方去玩,需要找路时,通常会“先看地图再找路”、或是“有路就走”。在确认移动范围时是先看地图,再利用地图的参考结果去找路。

而移动范围的确认结果都有“剩余步数”,从目的地反推回来就能得到回到出发点的最短距离,如图5-10所示。

从方格①(目的地)出发到起点有2条路线,不过两者距离相同。无论是从哪里出发,只要往剩余步数值最大的方向走,最后一定能抵达出发点。这就是找出跟“目前步数(脚印)十1”相同步数的方格,然后移动过去,请用图解看看。把这时候的运动路线记录下来,反推回去就可以得到从“起点”到“目的地”的最短路线。如果在寻找可移动范围时有记录“所有运动路线”,就不需要这个处理了。但若要把运动路线·记录下来,又会浪费太多内存空间。因为记录所有运动路线的工程也不算小,所以本书是采用重新寻找运动路线的方法。